import argparse
import binpacking
import os
import subprocess


def find_musics(fami_file, fami_path, out_path="../asm/audio/music.s"):
    header_size = 0
    musics = {}

    # exec famistudio export command
    result = subprocess.run(
        [
            fami_path,
            fami_file,
            "famistudio-asm-export",
            out_path,
            "-famistudio-asm-format:ca65",
        ],
        stdout=subprocess.PIPE,
    )

    # and parse stdout to get musics size
    log = result.stdout.decode("utf-8")
    for line in log.split("\n"):
        line = line.lstrip()
        if line.startswith("Info: "):
            line = line[6:]
            if line.startswith("Song"):
                line = line[5:].split(" size: ")
                musics[line[0][1:-1]] = int(line[1].split(" ")[0])
            elif line.startswith("Tempo envelopes") or line.startswith("Header") or line.startswith("Instruments"):
                size = line.split(" : ")[1].split(" ")[0]
                header_size += int(size)

    # remove generated assembly file (but not the dpcm one)
    os.remove(out_path)

    return musics, header_size


def find_banks(musics, MAX_SIZE=8192):
    # remove item that have no size
    k, v = list(musics.keys()), list(musics.values())
    for i in range(len(k)):
        if v[i] <= 0:
            del musics[k[i]]

    # find best banks
    bins = binpacking.to_constant_volume(musics, MAX_SIZE)

    # print
    for i, b in enumerate(bins):
        size = sum(b.values())
        print(f"Bank {i} (size={size}): {list(b.keys())}")

    return bins


def write_data_asm(bins, musics, out_path="../asm/audio/data.asm"):
    n_music = len(musics)  # sum([len(list(b.keys())) for b in bins])

    with open(out_path, "w") as f:
        f.write("; Autogenerated file\n")
        f.write(f"; Info:\n")
        f.write(f"; - {len(bins)} bank{'s' if len(bins) > 1 else ''}\n")
        f.write(f"; - {n_music} music{'s' if n_music > 1 else ''}\n\n")

        # write segments
        for i in range(len(bins)):
            f.write(f'.segment "MUS_BNK{i}"\n')
            f.write(f'.include "music_{i}.s"\n')
        f.write(f'.segment "SFX_BNK"\n')
        f.write(f'.include "sfx.s"\n')
        f.write(f'.segment "DPCM_BNK"\n')
        f.write(f'.incbin "dpcm.dmc"\n')
        f.write(f'.segment "LAST_BNK"\n')

        # write music_bank_table
        f.write("\nmusic_bank_table:\n")
        f.write("\n.byte MUS_BNK + $00 ; NONE\n")
        for mus_idx, (name, size) in enumerate(musics.items()):
            bnk = 0
            for i, b in enumerate(bins):
                if name in b.keys():
                    bnk = i
                    break
            bnk = f"{bnk:#0{2}x}"[2:]
            f.write(f".byte MUS_BNK + ${bnk} ; {mus_idx} - {name} ({size} bytes)\n")

        # write music_idx_table
        bank_count = [0] * len(bins)
        f.write("\nmusic_idx_table:\n")
        f.write("\n.byte $00 ; NONE\n")
        for mus_idx, (name, size) in enumerate(musics.items()):
            idx = 0
            for i, b in enumerate(bins):
                if name in b.keys():
                    idx = i
                    break
            i = f"{bank_count[idx]:#0{2}x}"[2:]
            f.write(f".byte ${i} ; {mus_idx} - {name} ({size} bytes)\n")
            bank_count[idx] += 1

        # write dpcm_samples
        f.write("\ndpcm_samples:\n")
        f.write(".byte $00+.lobyte(FAMISTUDIO_DPCM_PTR),$74,$8d,$40	;1 (phoenix_obj)\n")
        f.write(".byte $1d+.lobyte(FAMISTUDIO_DPCM_PTR),$54,$8d,$40	;2 (phoenix_holdit)\n")
        f.write(".byte $32+.lobyte(FAMISTUDIO_DPCM_PTR),$6a,$8c,$40	;3 (payne_obj)\n")


def export_music(bins, musics, fami_file, fami_path, out_path="../asm/audio/"):
    for bank_idx, b in enumerate(bins):
        # find music index
        index_list = []
        for mus_idx, (name, size) in enumerate(musics.items()):
            if name in b.keys():
                index_list.append(str(mus_idx))

        # exec command
        output = os.path.join(out_path, f"music_{bank_idx}.s")
        subprocess.run(
            [
                fami_path,
                fami_file,
                "famistudio-asm-export",
                output,
                f"-export-songs:{','.join(index_list)}",
                "-famistudio-asm-format:ca65",
            ]
        )

        # replace labels
        with open(output, "r") as f:
            lines = f.readlines()
        label = lines[6][:-2]
        for i in range(len(lines)):
            lines[i] = lines[i].replace(label, label + f"_{bank_idx}")
        with open(output, "w") as f:
            f.writelines(lines)

        # remove generated dpcm file
        dmc_file = os.path.join(out_path, f"music_{bank_idx}.dmc")
        if os.path.exists(dmc_file):
            os.remove(dmc_file)


def export_sfx(fami_file, fami_path, out_path="../asm/audio/"):
    # exec command
    output = os.path.join(out_path, f"sfx.s")
    subprocess.run(
        [
            fami_path,
            fami_file,
            "famistudio-asm-sfx-export",
            output,
            "-famistudio-asm-format:ca65",
        ]
    )

    # replace labels
    with open(output, "r") as f:
        lines = f.readlines()
    label = lines[7][:-2]
    for i in range(len(lines)):
        lines[i] = lines[i].replace(label, "sounds")
    with open(output, "w") as f:
        f.writelines(lines)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("fami_file", type=str, help="FamiStudio project file path")
    parser.add_argument("fami_sfx", type=str, help="FamiStudio SFX project file path")
    parser.add_argument("-fs", "--fami_path", required=False, default="famistudio.exe", type=str, help="Path to FamiStudio.exe")
    parser.add_argument("-ao", "--asm_out", required=False, default="../asm/audio/", type=str, help="Path to the assembly audio folder")
    args = parser.parse_args()

    if not os.path.exists(args.fami_path):
        print(f"Error: FamiStudio '{args.fami_path}' does not exist")
        exit(1)
    if not os.path.exists(args.fami_file):
        print(f"Error: FamiStudio project file '{args.fami_file}' does not exist")
        exit(1)
    if not os.path.exists(args.fami_sfx):
        print(f"Error: FamiStudio SFX project file '{args.fami_sfx}' does not exist")
        exit(1)
    if not os.path.exists(args.asm_out):
        print(f"Error: Assembly audio folder '{args.asm_out}' does not exist")
        exit(1)

    musics, header_size = find_musics(args.fami_file, args.fami_path, out_path=os.path.join(args.asm_out, "music.s"))
    bins = find_banks(musics, MAX_SIZE=8192 - header_size)
    write_data_asm(bins, musics, out_path=os.path.join(args.asm_out, "data.asm"))
    export_music(bins, musics, args.fami_file, args.fami_path, out_path=args.asm_out)
    export_sfx(args.fami_sfx, args.fami_path, out_path=args.asm_out)
